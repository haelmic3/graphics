<!--
Copyright (c) 2018 Michael Julian Moran
License information by request:
mailto:Michael_Moran1@student.uml.edu
-->
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8"/>
<meta name="description" content="Three dimentional modeler"/>
<meta name="keywords" content="HTML5 WebGl 3D modeler"/>
<meta name="author" content="Michael Julian Moran"/>
<title>Render Engine</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
html{
	background:#222;
	color:#ddd;
	font-family:arial;
}
body{
	margin:0;
}
.header{}
.context{}
.footer{}
</style>
<head>
<body>
<div class="header">The controls are not rendered yet.</div>
<div class="context">The viewport is not ready.</div>
<div class="footer">No progress.</div>
<!--
Using:
https://github.com/toji/gl-matrix
Wed Mar 28 19:36:02 EDT 2018
for mat4
using in `function drawScene'
https://raw.githubusercontent.com/toji/gl-matrix/master/dist/gl-matrix.js
-->
<script src="./gl-matrix.js"></script>

<!--
WebGl code influenced by mozila developer network webGl tutorial.
Wed Mar 28 16:36:13 EDT 2018:
https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
-->
<script>
window.VStext = `
	attribute vec4 aVertexPosition;

	uniform mat4 uModelViewMatrix;
	uniform mat4 uProjectionMatrix;

	void main()
	{
		gl_Position =	uProjectionMatrix *
				uModelViewMatrix *
				aVertexPosition;
	}
`;
window.FStext = `
	void main()
	{
		gl_FragColor = vec4(1.0,0.3,0.2,1.0);
	}
`;
function loadShader(gl, type, source)
{
	const shader = gl.createShader(type);
	
	// send source-code to object
	gl.shaderSource(shader,source);

	gl.compileShader(shader);
	if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS))
	{
		console.log("Error; failed to compile a shader:\n"+
		gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}
function initShaderProgram(gl,vs,fs)
{
	const vertexShader = loadShader(gl, gl.VERTEX_SHADER,vs);
	const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER,fs);

	const shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram,vertexShader);
	gl.attachShader(shaderProgram,fragmentShader);
	gl.linkProgram(shaderProgram);
	if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
	{
		console.log("Shader program build failed:\n"+
			gl.getProgramInfoLog(shaderProgram));
		return null;
	}
	return shaderProgram;
}
function initBuffers(gl)
{
	const positionBuffer = gl.createBuffer();

	// set `positionBuffer' as the buffer
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	// from this point forth it is done

	// create the array for a square
	const positions = [
		1.0,	1.0,
		-1.0,	1.0,
		1.0,	-1.0,
		-1.0,	-1.0
	];

	gl.bufferData(	gl.ARRAY_BUFFER,
			new Float32Array(positions),
			gl.STATIC_DRAW);
	return {position: positionBuffer}

}
function drawScene(gl, programInfo, buffers)
{
	//move this later...
	gl.clearColor(0.0,0.0,0.0,1.0);	// clear to opaque black
	gl.clearDepth(1.0)		// everything
	gl.enable(gl.DEPTH_TEST);	// enable depth testing
	gl.depthFunc(gl.LEQUAL);	// let foreground obscure
	//end of move

	// clear color and depth.
	gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

	// Set up perspective matrix.
	// Simulates a perspective camera.
	// 45 degree field of view
	const fov = 45 * Math.PI / 180; // radians
	// aspect ratio
	const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	const zNear = 0.1;
	const zFar = 100.0;
	const projectionMatrix = mat4.create();
	mat4.perspective(	projectionMatrix	// destination
			,	fov
			,	aspect
			,	zNear
			,	zFar
			);
	// load identity matrix into the model view
	const mvMatrix = mat4.create();
	// translate the model view to where we want to draw our model
	mat4.translate	(	mvMatrix	// destination
			,	mvMatrix	// input
			,	[-0.0,0.0,-6.0]	// translation
			);

	gl.bindBuffer(gl.ARRAY_BUFFER,buffers.position);
	gl.vertexAttribPointer
	(	programInfo.attribLocations.vertexPosition
	,	2		// we have 2 values per point
	,	gl.FLOAT	// data type used was f32
	,	false		// normalise
	,	0		// stride (bytes per segment) 0 = use above
	,	0		// offset (starting byte)
	);
	gl.enableVertexAttribArray
	(	programInfo.attribLocations.vertexPosition	);

	// use specified program to draw
	gl.useProgram(programInfo.program);

	// set shader uniforms
	gl.uniformMatrix4fv
	(	programInfo.uniformLocations.projectionMatrix
	,	false
	,	projectionMatrix
	);
	gl.uniformMatrix4fv
	(	programInfo.uniformLocations.modelViewMatrix
	,	false
	,	mvMatrix
	);
	gl.drawArrays
	(	gl.TRIANGLE_STRIP
	,	0			// offset
	,	4			// number of vertexes
	);
	
}
window.setup = function()
{
	// setup view
	window.view =
	{	header	:	document.body.children[0]
	,	context	:	document.body.children[1]
	,	footer	:	document.body.children[2]
	,	r	:
		{	canvas:undefined
		,	d:undefined
		}
	,	programInfo: undefined
	,	objectBuffer: undefined
	};
	// setup view.controls
	view.header.innerHTML=""+
	"Controls";
	// setup view.canvas
	view.context.innerHTML=""+
	"<canvas>\n"+
	"The HTML5 canvas element must be enabled to function.\n"+
	"</canvas>";
	// setup view.status
	view.footer.innerHTML="Loading finished.";
	setTimeout(function(){view.footer.innerHTML="";},500);
	

	// setup canvas
	window.onresize = function()
	{
		// #TODO!
		// calculate size
		// render for new size
		// apply render to canvas
	}
	
	view.r.canvas = view.context.children[0];
	view.r.d = view.r.canvas.getContext("webgl");
	if(!view.r.d)setTimeout(function()
		{view.footer.insertAdjacentHTML
			('beforeend',"WebGL failed.");
		},500);
	else
	{
		view.r.d.clearColor(0.5,0.5,0.5,1.0);
		view.r.d.clear(view.r.d.COLOR_BUFFER_BIT);
		view.programInfo =
		{	program: initShaderProgram(view.r.d,VStext,FStext)
		,	attribLocations:undefined
		,	uniformLocations:undefined
		}
		view.programInfo.attribLocations =
		{	vertexPosition: view.r.d.getAttribLocation
			(view.programInfo.program,"aVertexPosition")
		};
		view.programInfo.uniformLocations =
		{	projectionMatrix: view.r.d.getUniformLocation
			(view.programInfo.program,"uProjectionMatrix")
		,	modelViewMatrix: view.r.d.getUniformLocation
			(view.programInfo.program,"uModelViewMatrix")
		};
		view.objectBuffer = initBuffers(view.r.d);
		drawScene
		(	view.r.d
		,	view.programInfo
		,	view.objectBuffer
		);
		
	}
};setup();
</script>
</body>
</html>
